package uk.ac.ebi.fg.myequivalents.test;

import java.util.HashSet;
import java.util.Set;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.EntityTransaction;

import org.apache.commons.lang3.RandomUtils;
import org.junit.rules.ExternalResource;

import uk.ac.ebi.fg.myequivalents.access_control.model.User;
import uk.ac.ebi.fg.myequivalents.access_control.model.User.Role;
import uk.ac.ebi.fg.myequivalents.dao.access_control.UserDao;
import uk.ac.ebi.fg.myequivalents.managers.impl.db.DbManagerFactory;
import uk.ac.ebi.fg.myequivalents.managers.interfaces.EntityMappingManager;
import uk.ac.ebi.fg.myequivalents.managers.interfaces.ServiceManager;
import uk.ac.ebi.fg.myequivalents.model.Repository;
import uk.ac.ebi.fg.myequivalents.model.Service;
import uk.ac.ebi.fg.myequivalents.model.ServiceCollection;
import uk.ac.ebi.fg.myequivalents.resources.Resources;

/**
 * An helper to generate random mappings, to be used by tests.
 * This can also be used as An {@link ExternalResource} test rule in JUnit tests ({@link #generateMappings()} and
 * {@link #cleanUp()} will be called automatically). 
 *
 * @author brandizi
 * <dl><dt>Date:</dt><dd>12 Mar 2015</dd>
 *
 */
public class MappingsGenerator extends ExternalResource
{
	public static final String EDITOR_PASS = "test.password";
	public static final String EDITOR_SECRET = "test.secret";
	public static final User EDITOR_USER = new User ( 
		"test.editor", "Test Editor", "User", EDITOR_PASS, "test editor notes", Role.EDITOR, EDITOR_SECRET );

	public static final String ADMIN_PASS = "test.password";
	public static final String ADMIN_SECRET = "test.secret";
	public static final User ADMIN_USER = new User ( 
		"test.admin", "Test Admin", "User", ADMIN_PASS, "test admin notes", Role.ADMIN, ADMIN_SECRET );
	
	
	public static final String REPO_NAME_PREFIX = "test.generated.repo";
	public static final String SERV_COLL_NAME_PREFIX = "test.generated.sc";
	public static final String SERVICE_NAME_PREFIX = "test.generated.service";

	/**
	 * Change these values to fix the size of random elements that are generated.
	 */
	public int nrepositories = 5, nserviceCollections = 3,
		nservices = 10, nmappingBundles = 50, bundleMaxleSize = 5, maxMappingId = 100;
	
	
	/**
	 * <p>Generates {@link #nmappingBundles} random mappings, linked to {@link #nservices} randomly-generated services.
	 * Each mapping has a random size ranging from 2 to {@link #bundleMaxleSize}, generates up to 
	 * {@link #maxMappingId} + 1 entities.</p>
	 * 
	 * <p>Services are created using {@link #SERVICE_NAME_PREFIX}, mapping IDs are just numbers.</p>
	 * 
	 * <p>Everything is created using {@link #EDITOR_USER}, which is created in advance. 
	 * {@link #ADMIN_USER} is also generated, for your convenience.</p> 
	 *  
	 */
	public void generateMappings ()
	{		
		DbManagerFactory mgrFact = Resources.getInstance ().getMyEqManagerFactory ();
		EntityManagerFactory emf = mgrFact.getEntityManagerFactory ();
		EntityManager em = emf.createEntityManager ();
		
		UserDao userDao = new UserDao ( em );
		EntityTransaction ts = em.getTransaction ();
		ts.begin ();
		userDao.storeUnauthorized ( ADMIN_USER );
		userDao.storeUnauthorized ( EDITOR_USER );
		ts.commit ();
		em.close ();

		ServiceManager servMgr = mgrFact.newServiceManager ( EDITOR_USER.getEmail (), EDITOR_SECRET );

		// Some Repos and ServColl
		for ( int i = 0; i < nrepositories; i++ )
		{
			Repository r = new Repository ( REPO_NAME_PREFIX + i );
			r.setDescription ( "Test Repo, generated by " + this.getClass ().getName () );
			r.setTitle ( r.getDescription () );
			servMgr.storeRepositories ( r );
		}

		for ( int i = 0; i < nserviceCollections; i++ )
		{
			ServiceCollection sc = new ServiceCollection ( SERV_COLL_NAME_PREFIX + i, "testType" );
			sc.setDescription ( "Test Service Collection, generated by " + this.getClass ().getName () );
			sc.setTitle ( sc.getDescription () );
			servMgr.storeServiceCollections ( sc );
		}

		// Services
		for ( int i = 0; i < nservices; i++ )
		{
			Service s = new Service ( SERVICE_NAME_PREFIX + i, "testType" );
			s.setDescription ( "Testing Service, generated by " + this.getClass ().getName () );
			s.setTitle ( s.getDescription () );
			
			if ( nrepositories != 0 )
			{
				// Possibly add a container
				int repoId = RandomUtils.nextInt ( 0, nrepositories + 1 );
				if ( repoId != nrepositories ) {
					Repository r = servMgr.getRepositories ( REPO_NAME_PREFIX + repoId ).getRepositories ().iterator ().next ();
					s.setRepository ( r );
				}
			}
			if ( nserviceCollections != 0 )
			{
				int scId = RandomUtils.nextInt ( 0, nserviceCollections + 1 );
				if ( scId != nserviceCollections ) {
					ServiceCollection sc = servMgr
						.getServiceCollections ( SERV_COLL_NAME_PREFIX + scId ).getServiceCollections ().iterator ().next ();
					s.setServiceCollection ( sc );
				}
			}
			servMgr.storeServices ( s );
		}
		servMgr.close ();
		
		
		// Mapping bundles
		EntityMappingManager mapMgr = mgrFact.newEntityMappingManager ( EDITOR_USER.getEmail (), EDITOR_SECRET );
		for ( int i = 0; i < nmappingBundles; i++ )
		{
			// The bundle
			int bundleSize = RandomUtils.nextInt ( 2, bundleMaxleSize + 1 );
			Set<String> edids = new HashSet<> ();
			for ( int j = 0; j < bundleSize; j++ )
			{
				int serviceId = RandomUtils.nextInt ( 0, nservices );
				int eid = RandomUtils.nextInt ( 0, maxMappingId + 1 );
				edids.add ( SERVICE_NAME_PREFIX + serviceId + ':' + eid ); 
			}
			mapMgr.storeMappingBundle ( edids.toArray ( new String [ 0 ] ) );
		}
		
		mapMgr.close ();
	}
	
	/**
	 * Removes data that were created via {@link #generateMappings()}.
	 */
	public int cleanUp ()
	{
		DbManagerFactory mgrFact = Resources.getInstance ().getMyEqManagerFactory ();
		EntityManagerFactory emf = mgrFact.getEntityManagerFactory ();
		EntityManager em = emf.createEntityManager ();
		
		EntityTransaction ts = em.getTransaction ();
		ts.begin ();
		int result = 0;
		result += em.createNativeQuery ( 
			"DELETE FROM entity_mapping WHERE service_name LIKE '" + SERVICE_NAME_PREFIX + "%'" 
		).executeUpdate ();
		result += em.createNativeQuery ( 
			"DELETE FROM service WHERE name LIKE '" + SERVICE_NAME_PREFIX + "%'" 
		).executeUpdate ();
		ts.commit ();
		em.close ();

		// Auth procedures change this
		ADMIN_USER.setPassword ( ADMIN_PASS );
		ADMIN_USER.setApiPassword ( ADMIN_SECRET );
		EDITOR_USER.setPassword ( EDITOR_PASS );
		EDITOR_USER.setApiPassword ( EDITOR_SECRET );
		
		return result;
	}

	/**
	 * Invokes {@link #generateMappings()}.
	 */
	@Override
  protected void before() throws Throwable {
		this.generateMappings ();
	}

	/**
	 * Invokes {@link #cleanUp()}
	 */
	 @Override
   protected void after() {
		 this.cleanUp ();
	 }
}
